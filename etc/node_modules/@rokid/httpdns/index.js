// http-dns

var id = 131709
var cache = {}
var url = require('url')
var dns = require('dns')
var request = require('@rokid/request-promise').promisified
var logger = console

var hostList = [
  'homebase.rokid.com',
  'homebasemqtt.rokid.com',
  'homebase-pre.rokid.com',
  'mqtt-pre.rokid.com',
  'homebase.rokid-inc.com',
  'homebase.dev.rokid-inc.com',
]

function getIPs(originHostName, usingDefault) {
  return new Promise((resolve, reject) => {
    if (usingDefault) {
      reject(new Error(`${originHostName} using default dns`))
    } else if (hostList.indexOf(originHostName) < 0) {
      reject(new Error(`${originHostName} not in hostList`))
    } else {
      resolve()
    }
  }).then(() => {
    return request({
      uri: `http://203.107.1.33/${id}/d?host=${originHostName}`,
      timeout: 3000,
      json: true
    }).then(result => {
      if (!Array.isArray(result.ips) || result.ips.length < 1) {
        throw new Error(`Host Not resolved for ${originHostName}`)
      }
      return result
    })
  }).catch(err => {
    logger.error('remote dns error', err)
    return new Promise((resolve, reject) => {
      dns.lookup(originHostName, (dnsError, address, family) => {
        if (dnsError || family === 6) {
          logger.error('Host Not resolved ', family, dnsError)
          reject(new Error(`Host Not resolved for ${originHostName}`))
        } else {
          cache[originHostName] = {
            ips: [address],
            ttl: 30 * 60,
            host: originHostName,
            origin_ttl: 30 * 60,
          }
          resolve(cache[originHostName])
        }
      })
    })
  })
}

function resolveHost(originHostName) {
  var dnsCache = cache[originHostName]

  if (dnsCache) {
    if (Date.now() < dnsCache.expiredAt) {
      logger.info(`${originHostName} using default dns`, dnsCache.ips)
      return Promise.resolve(dnsCache.ips[0])
    }
  }
  return getIPs(originHostName).then((result) => {
    cache[originHostName] = dnsCache = Object.assign(result, {
      expiredAt: Date.now() + (result.ttl || 30 * 60) * 1000
    })
    logger.info('â›Ž   updated dns', dnsCache)
    // support multi ip
    return dnsCache.ips[0]
  })
}

function lookup(host, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }
  logger.info(`httpdns: lookup ${host}`)
  resolveHost(host, options)
    .then(ip => cb(null, ip, 4))
}

function resolveRequestOptions(options) {
  if (options.url || options.uri) {
    var urlObj = url.parse(options.url || options.uri)
    var originHostName = urlObj.hostname
    if (hostList.indexOf(originHostName) === -1) {
      return Promise.resolve(options)
    }

    var update = function (ip) {
      delete urlObj.host
      urlObj.hostname = ip
      var newURL = url.format(urlObj)
      options.url ? options.url = newURL : options.uri = newURL
      options.headers = Object.assign({}, options.headers, {
        host: originHostName
      })
      return options
    }

    if (!/^\d+(\.\d+){3}/.test(originHostName)) {
      return resolveHost(originHostName)
        .then(update)
    }
  }

  return Promise.resolve(options)
}

function requestWithDNS(options) {
  return resolveRequestOptions(options).then(options => {
    return request(options)
  })
}

/**
 * @param {Object} logger_
 * @returns
 */
module.exports = function (logger_) {
  if (logger_) {
    logger = logger_
  }
  return {
    resolve: resolveHost,
    resolveRequestOptions: resolveRequestOptions,
    requestWithDNS: requestWithDNS,
    lookup: lookup,
  }
}