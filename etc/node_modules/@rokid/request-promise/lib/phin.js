var http = require('http')
var https = require('https')
var url = require('url')
var qs = require('querystring')
var zlib = require('zlib')
var util = require('util')

/**
* phin options object. phin also supports all options from <a href="https://nodejs.org/api/http.html#http_http_request_options_callback">http.request(options, callback)</a> by passing them on to this method (or similar).
* @typedef {Object} phinOptions
* @property {string} url - URL to request (autodetect infers from this URL)
* @property {string} [method=GET] - Request method ('GET', 'POST', etc.)
* @property {string} [data] - Data to send as request body (phin may attempt to convert this data to a string if it isn't already)
* @property {Object} [form] - Object to send as form data (sets 'Content-Type' and 'Content-Length' headers, as well as request body) (overwrites 'data' option if present)
* @property {Object} [headers={}] - Request headers
* @property {string} [parse=none] - Response parsing. Errors will be given if the repsonse can't be parsed. ('none', 'json')
* @property {boolean} [stream=false] - Enable streaming of response. (Removes )
* @property {boolean} [compression=false] - Enable compression for request
* @property {?number} [timeout=null] - Request timeout in milliseconds
* @property {string} [hostname=autodetect] - URL hostname
* @property {Number} [port=autodetect] - URL port
* @property {string} [path=autodetect] - URL path
* @property {string} [auth=autodetect] - Request authentiction in 'user:password' format
*/

/**
* Response data callback
* @callback phinResponseCallback
* @param {?(Error|string)} error - Error if any occurred in request, otherwise null.
* @param {?http.serverResponse} phinResponse - phin response object. Like <a href='https://nodejs.org/api/http.html#http_class_http_serverresponse'>http.ServerResponse</a> but has a body property containing response body, unless stream. If stream option is enabled, a stream property will be provided to callback with a readable stream.
*/

/**
* Sends an HTTP request
* @param {phinOptions|string} options - phin options object (or string for auto-detection)
* @param {phinResponseCallback} [callback=null] - Callback to which data is sent upon request compvarion
*/
var phin = (opts, cb) => {
  if (typeof (opts) !== 'string') {
    if (!opts.hasOwnProperty('url') && !opts.hasOwnProperty('uri')) {
      throw new Error('Missing url option from options for request method.')
    }
  }

  var addr = typeof opts === 'object' ? url.parse(opts.url || opts.uri) : url.parse(opts)

  var options = {
    'hostname': addr.hostname,
    'port': addr.port || (addr.protocol.toLowerCase() === 'http:' ? 80 : 443),
    'path': addr.path,
    'method': 'GET',
    'headers': {},
    'auth': (addr.auth || null),
    'timeout': null,
    'parse': 'none',
    'stream': false,
    'body': null,
  }

  if (typeof opts === 'object') {
    options = Object.assign(options, opts)
  }
  options.port = Number(options.port)

  if (options.compressed === true) {
    options.headers['accept-encoding'] = 'gzip, deflate'
  }

  if (opts.hasOwnProperty('form')) {
    if (typeof opts.form !== 'object') {
      throw new Error('phin \'form\' option must be of type Object if present.')
    }

    var formDataString = qs.stringify(opts.form)

    options.headers['Content-Type'] = 'application/x-www-form-urlencoded'
    options.headers['Content-Length'] = Buffer.byteLength(formDataString)

    opts.data = formDataString
  }

  var req
  var resHandler = (res) => {
    var stream = res
    if (options.compressed === true) {
      if (res.headers['content-encoding'] === 'gzip') {
        stream = res.pipe(zlib.createGunzip())
      } else if (res.headers['content-encoding'] === 'deflate') {
        stream = res.pipe(zlib.createInflate())
      }
    }
    if (options.stream === true) {
      res.stream = stream
      cb(null, res)
    }
    else {
      res.body = new Buffer([])
      stream.on('data', (chunk) => {
        res.body = Buffer.concat([res.body, chunk])
      })
      stream.on('end', () => {
        if (!cb) return;
        if (options.parse === 'json' || options.json) {
          try {
            res.body = res.body.toString();
            var jsonBody = JSON.parse(res.body)
            return cb(null, jsonBody)
          } catch (err) {
            err.message = 'Invalid JSON received.'
            err.res = res;
            cb(err)
            return
          }
        }
        cb(null, res)
      })
    }
  }

  switch (addr.protocol.toLowerCase()) {
    case 'http:':
      req = http.request(options, resHandler)
      break
    case 'https:':
      req = https.request(options, resHandler)
      break
    default:
      if (cb) {
        cb(new Error('Invalid / unknown URL protocol. Expected HTTP or HTTPS.'), null)
      }
      return
  }

  if (typeof options.timeout === 'number') {
    setTimeout(() => {
      if (req.abort) {
        req.abort()
      } else if (req.socket) {
        req.socket.destroy() 
      }
      cb(new Error('Timeout has been reached.'), null)
      cb = null
    }, options.timeout)
  }

  req.on('error', (err) => {
    if (cb) {
      cb(err, null)
    }
  })

  var postData
  if (opts.data || opts.body) {
    postData = opts.data || opts.body

    if (!(postData instanceof Buffer) && typeof postData === 'object') {
      var contentType = options.headers['content-type'] || options.headers['Content-Type']
      if (contentType === 'application/x-www-form-urlencoded') {
        postData = qs.stringify(postData)
      }
      else {
        try {
          postData = JSON.stringify(postData)
        }
        catch (err) {
          cb(new Error('Couldn\'t stringify object. (Likely due to a circular reference.)'), null)
        }
      }
    }
  }
  req.end(postData)
}

// If we're running Node.js 8+, var's promisify it

phin.promisified = (opts, http) => {
  return new Promise((resolve, reject) => {
    phin(opts, (err, res) => {
      if (err) {
        reject(err)
      }
      else {
        resolve(res)
      }
    }, http)
  })
}

if (util.promisify) {
  phin[util.promisify.custom] = phin.promisified
}

module.exports = phin