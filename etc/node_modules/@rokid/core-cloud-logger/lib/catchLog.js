// dont use strict mode here

var fs = require('fs')
var util = require('util')
var EventEmitter = require('events').EventEmitter
var LOG_PATH = '/data/homebase/logs'
var LOG_MAX_FILE_SIZE = 512 * 1024
var LOG_MAX_SIZE = 1
var LOG_READ_HIGH_WATER_MARK = 24 * 1024
var empty = () => true

function CatchLog() {
  EventEmitter.call(this)
  init()
}

util.inherits(CatchLog, EventEmitter)

function init() {
  try {
    if (!fs.existsSync(LOG_PATH)) { fs.mkdirSync(LOG_PATH) }
    local.start()
  } catch (err) {
    console.error('initialized catchLog failed', err.message)
  }
}

function sizeof(loc) {
  return new Promise((resolve, reject) => {
    fs.stat(`${LOG_PATH}/${loc}`, (err, stat) => {
      resolve(err ? 0 : stat.size)
    })
  })
}

function rename(old, fresh) {
  return new Promise((resolve, reject) => {
    fs.rename(`${LOG_PATH}/${old}`, `${LOG_PATH}/${fresh}`, (err) => {
      err ? reject(err) : resolve()
    })
  })
}

function realign() {
  return new Promise((resolve, reject) => {
    fs.readdir(LOG_PATH, (err, files) => {
      err ? reject(err) : resolve(files)
    })
  }).then((files) => {
    var extract = (name) => /homebase-(\d+)?\.log/.exec(name)
    return files.sort().reverse()
      .map(extract).filter((m) => m !== null)
      .reduce((pending, m) => {
        var id = parseInt(m[1])
        if (id && id < LOG_MAX_SIZE) {
          return pending.then(() =>
            rename(m.input, `homebase-${id + 1}.log`))
        } else {
          return pending
        }
      }, Promise.resolve())
  }).then(() => {
    return rename('homebase.log', 'homebase-1.log')
  })
}

/**
 * local: the map to file
 */
var local = {
  /**
   * logs
   */
  logs: [],
  /**
   * duration to flush
   */
  duration: 5 * 1000,
  /**
   * flush
   */
  flush: function () {
    sizeof('homebase.log')
      .then((size) => {
        if (size >= LOG_MAX_FILE_SIZE) {
          return realign()
        }
      })
      .then(() => {
        if (this.logs.length > 0) {
          return this.write()
        }
      })
      .catch((err) => {
        console.error('err', err)
      })
  },
  /**
   * start
   */
  start: function () {
    setInterval(this.flush.bind(this), this.duration)
  },
  /**
   * write
   */
  write: function () {
    var buf = new Buffer(this.logs.map(line => line + '\n').join(''))
    this.logs.length = 0
    fs.open(`${LOG_PATH}/homebase.log`, 'a', 438, (err, fd) => {
      if (err) {
        console.error('error open file ' + location)
        return
      }
      fs.write(
        fd, buf, 0, buf.length, () => fs.close(fd, empty))
    })
  },
}

CatchLog.prototype.saveLog = function (now, level, msg, name, pid) {
  local.logs.push(`[${pid}] [${now}] [${name}] [${level}] ${msg}`)
}

/**
 * @param {String} fileNumber 
 * @returns {Promise<String>}
 */
CatchLog.prototype.readLogStream = function (num) {
  num = num ? '-' + num : ''
  var filePath = `${LOG_PATH}/homebase${num}.log`
  return this.readStream(filePath)
}

CatchLog.prototype.readStream = function (filePath, options) {
  return new Promise((resolve, reject) => {
    console.log(`read stream ${filePath}`)
    var startTime = Date.now()
    fs.stat(filePath, (err, stat) => {
      if (err) {
        reject(err)
        return
      }

      var fsize = stat.size
      console.log(`log ${filePath} ${fsize}bytes in ${Date.now() - startTime}`)
      var start = fsize > LOG_MAX_FILE_SIZE ? fsize - LOG_MAX_FILE_SIZE : 0
      options = Object.assign({}, options, {
        start: start
      })
      var stream = fs.createReadStream(filePath, options)
      stream.readableHighWaterMark = LOG_READ_HIGH_WATER_MARK
      resolve(stream)
    })
  })
}

var catchLog
function getInstance() {
  if (!catchLog) {
    catchLog = new CatchLog()
  }
  return catchLog
}

module.exports.getInstance = getInstance
