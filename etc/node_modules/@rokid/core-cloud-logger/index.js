var rp = require('@rokid/request-promise').promisified
var getTokenFailureInterval = 30 * 1000
var crypto = require('crypto')

var log_levels = {
  none: 0,
  debug: 1,
  info: 2,
  warn: 3,
  error: 4,
  fatal: 5,
  max: 6,
}

var native = null
var isInited = false
var enableStdPrint = true
var enableUpload = false
var pipeToParent = false
var logStore = 'rokid_mini'
var processLogMsgType = '__cloud_log__'
var watchingChildren = {}
var profile = {}

function Logger(name) {
  if (!name) { name = 'syst' }
  if (name.length > 4) { name = name.slice(0, 4) }

  // map for 1/2/3
  switch (name.length) {
    case 1: name = ` :${name} `; break
    case 2: name = ` ${name} `; break
    case 3: name = `:${name}`; break
  }
  this.name = name
}

/**
 * makeSign
 */
function makeSign(info) {
  var s = `key=${info.key}&` +
    `device_type_id=${info.deviceTypeId}&` +
    `device_id=${info.sn}&` +
    `service=${info.service}&` +
    `version=${info.version}&` +
    `time=${info.time}&` +
    `secret=${info.secret}`
  return crypto.createHash('md5')
    .update(s, 'utf-8').digest('hex').toUpperCase()
}

function authorization(info) {
  return `version=${info.version};`+
  `time=${info.time};`+
  `sign=${info.sign};`+
  `key=${info.key};`+
  `device_type_id=${info.deviceTypeId};`+
  `device_id=${info.sn};`+
  `service=${info.service}`
}

function getToken () {
  function doCheck() {
    var props = {
      service: 'rest',
      version: '1',
      time: Math.round(Date.now() / 1000).toString(),
      deviceTypeId: profile.deviceTypeId,
      sn: profile.sn,
      secret: profile.appSecret,
      key: profile.key
    }
    var sign = makeSign(props)
    var authKey = authorization(Object.assign({}, props, { sign: sign }))
    var env = profile.env === 'dev' || 'test' ? '-dev': ''
    console.log('props', env, props, authKey)
    return rp({
      uri: `https://apigwrest${env}.open.rokid.com/v1/sts/StsService/GetToken`,
      method: 'POST',
      timeout: 15 * 1000,
      json: true,
      headers: {
        'Content-Type': 'application/json',
        "Authorization": authKey
      },
      body: {}
    })
    .catch(err => {
      console.log('==== error ====', env, props, authKey)
      throw err
    })
  }
  doCheck().then(result => {
    if (typeof result !== 'object' 
        && result.message !== 'success'
        && result.resultCode === 1
        && !result.accessKeyId
        && !result.accessKeySecret
        && !result.expiration
        && !result.token) {
      Logger.error(`get token error ${result}`)
      setTimeout(getToken, getTokenFailureInterval)
      return
    }
    var expiration = new Date(result.stsInfo.expiration).getTime()
    var refreshTokenTime = expiration - Date.now() - 5 * 60 * 1000
    setTimeout(getToken, refreshTokenTime)
    native.refreshToken(
      result.stsInfo.accessKeyId,
      result.stsInfo.accessKeySecret,
      result.stsInfo.token
    )
    console.log(`refreshTokenTime=${refreshTokenTime}, request result=${JSON.stringify(result.stsInfo)}`)
  })
  .catch(err => {
      console.log('update error', err)
      setTimeout(getToken, getTokenFailureInterval)
  })
}

/**
 * @param {String} level logger level, info|warn|error etc..
 * @param {Array} args log argument
 * @param {String} prefix log prefix string
 * @param {String} suffix log suffix string
 */
Logger.prototype._doLog = function (level, args, prefix, suffix, pid) {
  if (!enableUpload && !enableStdPrint) {
    return
  }
  if (enableStdPrint && pipeToParent) {
    process.send(JSON.stringify({
      type: processLogMsgType,
      name: this.name,
      level: level,
      args: Array.prototype.map.call(args, v => v),
      prefix: prefix,
      suffix: suffix
    }))
    return
  }
  var now = (new Date()).toISOString()
  var msg = ''
  for (var i = 0; i < args.length; ++i) {
    var c = args[i]
    if (c instanceof Error) {
      msg += ` Error: ${c.message}, ${c.name || ''}, ${c.code || ''}`
    } else if (typeof c === 'object') {
      msg += ` ${JSON.stringify(c)}`
    } else if (c && c.toString) {
      msg += ` ${c.toString()}`
    }
  }
  if (enableUpload && native) {
    var levelNumber = log_levels[level]
    if (levelNumber && levelNumber >= log_levels.info) {
      native.log(this.name, level, now, msg)
    }
  }
  if (enableStdPrint) {
    prefix = prefix || ''
    suffix = suffix || ''
    pid = pid || process.pid
    console[level](
      `${prefix}[${pid}] [${now}] [${this.name}] [${level}] ${msg}${suffix}`
    )
  }
}

Logger.prototype.log = function () {
  this._doLog('log', arguments)
}

Logger.prototype.info = function () {
  this._doLog('info', arguments, '\x1B[0;32m', '\x1B[0m')
}

Logger.prototype.warn = function () {
  this._doLog('warn', arguments, '\x1B[0;33m', '\x1B[0m')
}

Logger.prototype.error = function () {
  this._doLog('error', arguments, '\x1B[0;31m', '\x1B[0m')
}

Logger.prototype.debug = function () {
  this._doLog('debug', arguments)
}

module.exports = {

  /**
   * get a named logger, the logger is configured by initGlobalOptions
   * @param {String} name logger name
   * @return {Logger}
   */
  get: function (name) {
    if (!isInited) {
      throw new Error('logger is not inited')
    }
    var logger = new Logger(name)
    return logger
  },

  /**
   * init logger, call this method before log
   * @param {Object} options logger global options
   * @param {Boolean} options.enableStdPrint 日志输出到控制台，默认true
   * @param {Boolean} options.enableUpload 日志发送到云端，默认false
   * @param {Boolean} options.pipeToParent \
   *  日志发送到父进程，设置了此选项后所在进程将不会输出任何日志并忽略hints，默认false
   * @param {Object?} options.configs
   * @param {String?} options.configs.logStore 日志服务logStore
   * @param {String?} options.configs.name topic名字
   * @param {String?} options.configs.project 服务project
   * @param {Number?} options.configs.bytesPerPackage \
   *  指定每个缓存的日志包的大小上限
   * @param {Number?} options.configs.countPerPackage \
   *  指定每个缓存的日志包中包含日志数量的最大值
   * @param {Number?} options.configs.packageTimeout \
   *  指定被缓存日志的发送超时时间，如果缓存超时，则会被立即发送
   * @param {Number?} options.configs.maxBufferBytes \
   *  指定单个Producer Client实例可以使用的内存的上限
   */
  initGlobalOptions: function (options) {
    if (typeof options !== 'object') {
      throw new Error('logger options should be an object')
    }
    if (isInited) {
      return
    }
    isInited = true
    this.setEnableStdPrint(options.enableStdPrint)
    this.setEnableUpload(options.enableUpload)
    this.setPipeToParent(options.pipeToParent)
    this.setLogStore(options.sn)
    if (enableUpload && !pipeToParent) {
      var configs = Object.assign({}, {
        hardware: 'amlogic',
        project: 'rokid-linux',
        name: 'iot',
        logStore: logStore,
        bytesPerPackage: 32 * 1024,
        countPerPackage: 5,
        packageTimeout: 3000,
        maxBufferBytes: 1 * 1024 * 1024,
      }, options.configs)
      try {
        var hardware = configs.hardware
        if (hardware === 'amlogic') {
          native = require('./logger_bridge_amlogic.node')
        } else if (hardware === 'kamino') {
          native = require('./logger_bridge_kamino.node')
        } else {
          native = null
          logger.error(`unsupported platform ${hardware}`)
          return
        }
        native.init(enableUpload ? 1 : 0, configs)
      } catch (err) {
        console.error('cannot enable log upload in current platform', err)
      }
    }
  },

  /**
   * set logger hints
   * @param {Object} hints logger message hints
   * @param {String?} hints.sn
   * @param {String?} hints.deviceTypeId
   * @param {String?} hints.osVersion
   * @param {String?} hints.homebaseVersion
   * @param {String?} hints.env
   * @param {String?} hints.masterId
   */
  setHints: function (hints) {
    if (native) {
      native.setHints(hints || {})
    }
  },

  startToken: function (p) {
    profile = p
    return getToken()
  },

  setEnableUpload: function (b) {
    enableUpload = typeof b === 'boolean' ? b : false
  },

  setEnableStdPrint: function (b) {
    enableStdPrint = typeof b === 'boolean' ? b : true
  },

  setLogStore: function (sn) {
    if (/^03/.test(sn)) {
      logStore = 'rokid_mini'
    } else if (/^04/.test(sn)) {
      logStore = 'rokid_me'
    } else if (/^XYMN/.test(sn)) {
      logStore = 'rokid_xmly_mini'
    } else if (/^05/.test(sn)) {
      logStore = 'kamino_naboo'
    } else if (/^06/.test(sn)) {
      logStore = 'kamino_universal'
    }
  },

  setPipeToParent: function (b) {
    pipeToParent = typeof b === 'boolean' ? b : false
    if (pipeToParent) {
      if (!process.send) {
        throw new Error('cannot pipe, current process is the toppest process')
      }
    }
  },

  /**
   * 停止监听某个进程的日志
   * @param {Object} 进程
   */
  unwatchChild: function (child) {
    child.removeListener('message', watchingChildren[child.pid])
    delete watchingChildren[child.pid]
  },

  /**
   * 监听某个进程日志
   * @param {Object} 进程
   */
  watchChild: function (child) {
    var cb = function (data) {
      var msg
      try {
        msg = JSON.parse(data)
      } catch (err) {
        return
      }
      if (msg.type !== processLogMsgType) {
        return
      }
      var name = msg.name
      var level = msg.level
      var args = msg.args
      var prefix = msg.prefix
      var suffix = msg.suffix
      var pid = child.pid
      var self = { name: name }
      Logger.prototype._doLog.call(self, level, args, prefix, suffix, pid)
    }
    child.on('message', cb)
    watchingChildren[child.pid] = cb
  }
}