var log_levels = {
  none: 0,
  debug: 1,
  info: 2,
  warn: 3,
  error: 4,
  fatal: 5,
  max: 6,
}

var native = null
var isInited = false
var enableStdPrint = true
var enableUpload = false
var pipeToParent = false
var processLogMsgType = '__cloud_log__'
var watchingChildren = {}

function Logger(name) {
  if (!name) { name = 'syst' }
  if (name.length > 4) { name = name.slice(0, 4) }

  // map for 1/2/3
  switch (name.length) {
    case 1: name = ` :${name} `; break
    case 2: name = ` ${name} `; break
    case 3: name = `:${name}`; break
  }
  this.name = name
}

/**
 * @param {String} level logger level, info|warn|error etc..
 * @param {Array} args log argument
 * @param {String} prefix log prefix string
 * @param {String} suffix log suffix string
 */
Logger.prototype._doLog = function (level, args, prefix, suffix, pid) {
  if (!enableUpload && !enableStdPrint) {
    return
  }
  if (enableStdPrint && pipeToParent) {
    process.send(JSON.stringify({
      type: processLogMsgType,
      name: this.name,
      level: level,
      args: Array.prototype.map.call(args, v => v),
      prefix: prefix,
      suffix: suffix
    }))
    return
  }
  var now = (new Date()).toISOString()
  var msg = ''
  for (var i = 0; i < args.length; ++i) {
    var c = args[i]
    if (c instanceof Error) {
      msg += ` Error: ${c.message}, ${c.name || ''}, ${c.code || ''}`
    } else if (typeof c === 'object') {
      msg += ` ${JSON.stringify(c)}`
    } else if (c && c.toString) {
      msg += ` ${c.toString()}`
    }
  }
  if (enableUpload && native) {
    var levelNumber = log_levels[level]
    if (levelNumber && levelNumber >= log_levels.info) {
      native.log(this.name, level, now, msg)
    }
  }
  if (enableStdPrint) {
    prefix = prefix || ''
    suffix = suffix || ''
    pid = pid || process.pid
    console[level](
      `${prefix}[${pid}] [${now}] [${this.name}] [${level}] ${msg}${suffix}`
    )
  }
}

Logger.prototype.log = function () {
  this._doLog('log', arguments)
}

Logger.prototype.info = function () {
  this._doLog('info', arguments, '\x1B[0;32m', '\x1B[0m')
}

Logger.prototype.warn = function () {
  this._doLog('warn', arguments, '\x1B[0;33m', '\x1B[0m')
}

Logger.prototype.error = function () {
  this._doLog('error', arguments, '\x1B[0;31m', '\x1B[0m')
}

Logger.prototype.debug = function () {
  this._doLog('debug', arguments)
}

module.exports = {

  /**
   * get a named logger, the logger is configured by initGlobalOptions
   * @param {String} name logger name
   * @return {Logger}
   */
  get: function (name) {
    if (!isInited) {
      throw new Error('logger is not inited')
    }
    var logger = new Logger(name)
    return logger
  },

  /**
   * init logger, call this method before log
   * @param {Object} options logger global options
   * @param {Boolean} options.enableStdPrint 日志输出到控制台，默认true
   * @param {Boolean} options.enableUpload 日志发送到云端，默认false
   * @param {Boolean} options.pipeToParent \
   *  日志发送到父进程，设置了此选项后所在进程将不会输出任何日志并忽略hints，默认false
   * @param {Object?} options.configs
   * @param {String?} options.configs.logStore 日志服务logStore
   * @param {String?} options.configs.name topic名字
   * @param {String?} options.configs.project 服务project
   * @param {Number?} options.configs.bytesPerPackage \
   *  指定每个缓存的日志包的大小上限
   * @param {Number?} options.configs.countPerPackage \
   *  指定每个缓存的日志包中包含日志数量的最大值
   * @param {Number?} options.configs.packageTimeout \
   *  指定被缓存日志的发送超时时间，如果缓存超时，则会被立即发送
   * @param {Number?} options.configs.maxBufferBytes \
   *  指定单个Producer Client实例可以使用的内存的上限
   */
  initGlobalOptions: function (options) {
    if (typeof options !== 'object') {
      throw new Error('logger options should be an object')
    }
    if (isInited) {
      return
    }
    isInited = true
    this.setEnableStdPrint(options.enableStdPrint)
    this.setEnableUpload(options.enableUpload)
    this.setPipeToParent(options.pipeToParent)
    if (enableUpload && !pipeToParent) {
      var configs = Object.assign({}, {
        hardware: 'amlogic',
        project: 'rokid-linux',
        name: 'iot',
        logStore: 'rokid_mini',
        bytesPerPackage: 32 * 1024,
        countPerPackage: 5,
        packageTimeout: 3000,
        maxBufferBytes: 1 * 1024 * 1024,
      }, options.configs)
      try {
        var hardware = configs.hardware
        if (hardware === 'amlogic') {
          native = require('./logger_bridge_amlogic.node')
        } else if (hardware === 'kamino') {
          native = require('./logger_bridge_kamino.node')
        } else {
          native = null
          logger.error(`unsupported platform ${hardware}`)
          return
        }
        native.init(enableUpload ? 1 : 0, configs)
      } catch (err) {
        console.error('cannot enable log upload in current platform', err)
      }
    }
  },

  /**
   * set logger hints
   * @param {Object} hints logger message hints
   * @param {String?} hints.sn
   * @param {String?} hints.deviceTypeId
   * @param {String?} hints.osVersion
   * @param {String?} hints.homebaseVersion
   * @param {String?} hints.env
   * @param {String?} hints.masterId
   */
  setHints: function (hints) {
    if (native) {
      native.setHints(hints || {})
    }
  },

  setEnableUpload: function (b) {
    enableUpload = typeof b === 'boolean' ? b : false
  },

  setEnableStdPrint: function (b) {
    enableStdPrint = typeof b === 'boolean' ? b : true
  },

  setPipeToParent: function (b) {
    pipeToParent = typeof b === 'boolean' ? b : false
    if (pipeToParent) {
      if (!process.send) {
        throw new Error('cannot pipe, current process is the toppest process')
      }
    }
  },

  /**
   * 停止监听某个进程的日志
   * @param {Object} 进程
   */
  unwatchChild: function (child) {
    child.removeListener('message', watchingChildren[child.pid])
    delete watchingChildren[child.pid]
  },

  /**
   * 监听某个进程日志
   * @param {Object} 进程
   */
  watchChild: function (child) {
    var cb = function (data) {
      var msg
      try {
        msg = JSON.parse(data)
      } catch (err) {
        return
      }
      if (msg.type !== processLogMsgType) {
        return
      }
      var name = msg.name
      var level = msg.level
      var args = msg.args
      var prefix = msg.prefix
      var suffix = msg.suffix
      var pid = child.pid
      var self = { name: name }
      Logger.prototype._doLog.call(self, level, args, prefix, suffix, pid)
    }
    child.on('message', cb)
    watchingChildren[child.pid] = cb
  }
}